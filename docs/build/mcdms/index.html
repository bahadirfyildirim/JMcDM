<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Multiple Criteria Decision Making Tools · JMcDM</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JMcDM</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Multiple Criteria Decision Making Tools</a><ul class="internal"><li><a class="tocitem" href="#TOPSIS"><span>TOPSIS</span></a></li><li><a class="tocitem" href="#ELECTRE"><span>ELECTRE</span></a></li><li><a class="tocitem" href="#DEMATEL"><span>DEMATEL</span></a></li><li><a class="tocitem" href="#MOORA"><span>MOORA</span></a></li><li><a class="tocitem" href="#VIKOR"><span>VIKOR</span></a></li><li><a class="tocitem" href="#AHP"><span>AHP</span></a></li><li><a class="tocitem" href="#Data-Envelopment-Analysis"><span>Data Envelopment Analysis</span></a></li><li><a class="tocitem" href="#Grey-Relational-Analysis"><span>Grey Relational Analysis</span></a></li><li><a class="tocitem" href="#Non-dominated-Sorting"><span>Non-dominated Sorting</span></a></li><li><a class="tocitem" href="#SAW"><span>SAW</span></a></li><li><a class="tocitem" href="#ARAS"><span>ARAS</span></a></li><li><a class="tocitem" href="#WPM"><span>WPM</span></a></li><li><a class="tocitem" href="#WASPAS"><span>WASPAS</span></a></li><li><a class="tocitem" href="#EDAS"><span>EDAS</span></a></li><li><a class="tocitem" href="#MARCOS"><span>MARCOS</span></a></li><li><a class="tocitem" href="#MABAC"><span>MABAC</span></a></li><li><a class="tocitem" href="#MAIRCA"><span>MAIRCA</span></a></li><li><a class="tocitem" href="#COPRAS"><span>COPRAS</span></a></li><li><a class="tocitem" href="#PROMETHEE"><span>PROMETHEE</span></a></li><li><a class="tocitem" href="#CoCoSo"><span>CoCoSo</span></a></li><li><a class="tocitem" href="#Critic"><span>Critic</span></a></li><li><a class="tocitem" href="#CODAS"><span>CODAS</span></a></li></ul></li><li><a class="tocitem" href="../game/">Zero-sum Game Solver</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Multiple Criteria Decision Making Tools</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Multiple Criteria Decision Making Tools</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jbytecode/JMcDM/blob/master/docs/src/mcdms.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Multiple-Criteria-Decision-Making-Tools"><a class="docs-heading-anchor" href="#Multiple-Criteria-Decision-Making-Tools">Multiple Criteria Decision Making Tools</a><a id="Multiple-Criteria-Decision-Making-Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Criteria-Decision-Making-Tools" title="Permalink"></a></h1><h2 id="TOPSIS"><a class="docs-heading-anchor" href="#TOPSIS">TOPSIS</a><a id="TOPSIS-1"></a><a class="docs-heading-anchor-permalink" href="#TOPSIS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.topsis" href="#JMcDM.topsis"><code>JMcDM.topsis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    topsis(decisionMat, weights, fns)</code></pre><p>Apply TOPSIS (Technique for Order of Preference by Similarity to Ideal Solution) method  for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n candidate (or strategy) and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of function that are either minimize or maximize.</li></ul><p><strong>Description</strong></p><p>topsis() applies the TOPSIS method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::TopsisResult</code>: TopsisResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame();
julia&gt; df[:, :x] = Float64[9, 8, 7];
julia&gt; df[:, :y] = Float64[7, 7, 8];
julia&gt; df[:, :z] = Float64[6, 9, 6];
julia&gt; df[:, :q] = Float64[7, 6, 6];

julia&gt; w = Float64[4, 2, 6, 8];

julia&gt; df
3×4 DataFrame
 Row │ x        y        z        q       
     │ Float64  Float64  Float64  Float64 
─────┼────────────────────────────────────
   1 │     9.0      7.0      6.0      7.0
   2 │     8.0      7.0      9.0      6.0
   3 │     7.0      8.0      6.0      6.0

julia&gt; fns = makeminmax([maximum, maximum, maximum, maximum]);
julia&gt; result = topsis(df, w, fns);

julia&gt; result.bestIndex
2

julia&gt; result.scores
3-element Array{Float64,1}:
 0.38768695492211824
 0.6503238218850163
 0.08347670030339041</code></pre><p><strong>References</strong></p><p>Hwang, C.L.; Yoon, K. (1981). Multiple Attribute Decision Making: Methods and Applications. New York: Springer-Verlag</p><p>Celikbilek Yakup, Cok Kriterli Karar Verme Yontemleri, Aciklamali ve Karsilastirmali Saglik Bilimleri Uygulamalari ile. Editor: Muhlis Ozdemir, Nobel Kitabevi, Ankara, 2018</p><p>İşletmeciler, Mühendisler ve Yöneticiler için Operasyonel, Yönetsel ve Stratejik Problemlerin Çözümünde Çok Kriterli Karar verme Yöntemleri, Editörler: Bahadır Fatih Yıldırım ve Emrah Önder, Dora, 2. Basım, 2015, ISBN: 978-605-9929-44-8</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/fcfab8266915b131f587bf03a9a1e2b1bec357ac/src/topsis.jl#L1-L59">source</a></section></article><h2 id="ELECTRE"><a class="docs-heading-anchor" href="#ELECTRE">ELECTRE</a><a id="ELECTRE-1"></a><a class="docs-heading-anchor-permalink" href="#ELECTRE" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.electre" href="#JMcDM.electre"><code>JMcDM.electre</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    electre(decisionMat, weights, fns)</code></pre><p>Apply ELECTRE (ELimination Et Choice Translating REality) method  for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n candidate (or strategy) and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of function that are either minimize or maximize.</li></ul><p><strong>Description</strong></p><p>electre() applies the ELECTRE method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::ElectreResult</code>: TopsisResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; w =  [0.110, 0.035, 0.379, 0.384, 0.002, 0.002, 0.010, 0.077];
julia&gt; Amat = [
      100 92 10 2 80 70 95 80 ;
      80  70 8  4 100 80 80 90 ;
      90 85 5 0 75 95 70 70 ; 
      70 88 20 18 60 90 95 85
    ];

julia&gt; dmat = makeDecisionMatrix(Amat);
julia&gt; fns = makeminmax([maximum for i in 1:8]);
julia&gt; result = electre(dmat, w, fns)

julia&gt; dmat
4×8 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4     Crt5     Crt6     Crt7     Crt8    
     │ Float64  Float64  Float64  Float64  Float64  Float64  Float64  Float64 
─────┼────────────────────────────────────────────────────────────────────────
   1 │   100.0     92.0     10.0      2.0     80.0     70.0     95.0     80.0
   2 │    80.0     70.0      8.0      4.0    100.0     80.0     80.0     90.0
   3 │    90.0     85.0      5.0      0.0     75.0     95.0     70.0     70.0
   4 │    70.0     88.0     20.0     18.0     60.0     90.0     95.0     85.0

julia&gt; result.bestIndex
(4,)

julia&gt; result.C
4-element Array{Float64,1}:
  0.3693693693693696
  0.01501501501501501
 -2.473473473473473
  2.0890890890890894

julia&gt; result.D
4-element Array{Float64,1}:
  0.1914244325928971
 -0.19039293350192432
  2.884307608766315
 -2.885339107857288</code></pre><p><strong>References</strong></p><p>Celikbilek Yakup, Cok Kriterli Karar Verme Yontemleri, Aciklamali ve Karsilastirmali Saglik Bilimleri Uygulamalari ile. Editor: Muhlis Ozdemir, Nobel Kitabevi, Ankara, 2018</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/fcfab8266915b131f587bf03a9a1e2b1bec357ac/src/electre.jl#L1-L63">source</a></section></article><h2 id="DEMATEL"><a class="docs-heading-anchor" href="#DEMATEL">DEMATEL</a><a id="DEMATEL-1"></a><a class="docs-heading-anchor-permalink" href="#DEMATEL" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.dematel" href="#JMcDM.dematel"><code>JMcDM.dematel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    dematel(comparisonMat; threshold = nothing)</code></pre><p>Apply Dematel for a given comparison matrix.</p><p><strong>Arguments:</strong></p><ul><li><code>comparisonMat::Array{Float,2}</code>: n × m matrix of input values. </li><li><code>threshold::Union{Nothing, Float64}</code>: Optional threshold used in calculating values of influence matrix. It is calculated when the argument is omitted. </li></ul><p><strong>Description</strong></p><p>dematel() applies the Dematel method to calculate criteria weights, possibly for use in another multi-criteria decision making tool.</p><p><strong>Output</strong></p><ul><li><code>::DematelResult</code>: DematelResult object that holds many results including weights for each single criterion.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; K = [
        0 3 0 2 0 0 0 0 3 0;
        3 0 0 0 0 0 0 0 0 2;
        4 1 0 2 1 3 1 2 3 2;
        4 1 4 0 1 2 0 1 0 0;
        3 2 3 1 0 3 0 2 0 0;
        4 1 4 4 0 0 0 1 1 3;
        3 0 0 0 0 2 0 0 0 0;
        3 0 4 3 2 3 1 0 0 0;
        4 3 2 0 0 1 0 0 0 2;
        2 1 0 0 0 0 0 0 3 0
    ];

julia&gt; dmat = makeDecisionMatrix(K);
julia&gt; result = dematel(dmat);

julia&gt; result.weights
10-element Array{Float64,1}:
 0.1686568559124561
 0.07991375718719543
 0.14006200243438863
 0.10748052790517183
 0.08789022388276985
 0.12526272598854982
 0.03067915023486491
 0.10489168834828348
 0.092654758940811
 0.06250830916550884</code></pre><p><strong>References</strong></p><p>Celikbilek Yakup, Cok Kriterli Karar Verme Yontemleri, Aciklamali ve Karsilastirmali Saglik Bilimleri Uygulamalari ile. Editor: Muhlis Ozdemir, Nobel Kitabevi, Ankara, 2018</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/fcfab8266915b131f587bf03a9a1e2b1bec357ac/src/dematel.jl#L1-L52">source</a></section></article><h2 id="MOORA"><a class="docs-heading-anchor" href="#MOORA">MOORA</a><a id="MOORA-1"></a><a class="docs-heading-anchor-permalink" href="#MOORA" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.moora" href="#JMcDM.moora"><code>JMcDM.moora</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    moora(decisionMat, weights, fns)</code></pre><p>Apply MOORA (Multi-Objective Optimization By Ratio Analysis) method for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n candidate (or strategy) and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of function that are either maximum or minimum.</li></ul><p><strong>Description</strong></p><p>moora() applies the MOORA method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MooraResult</code>: MooraResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; w =  [0.110, 0.035, 0.379, 0.384, 0.002, 0.002, 0.010, 0.077];

julia&gt; Amat = [
             100 92 10 2 80 70 95 80 ;
             80  70 8  4 100 80 80 90 ;
             90 85 5 0 75 95 70 70 ; 
             70 88 20 18 60 90 95 85
           ];

julia&gt; dmat = makeDecisionMatrix(Amat)
4×8 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4     Crt5     Crt6     Crt7     Crt8    
     │ Float64  Float64  Float64  Float64  Float64  Float64  Float64  Float64 
─────┼────────────────────────────────────────────────────────────────────────
   1 │   100.0     92.0     10.0      2.0     80.0     70.0     95.0     80.0
   2 │    80.0     70.0      8.0      4.0    100.0     80.0     80.0     90.0
   3 │    90.0     85.0      5.0      0.0     75.0     95.0     70.0     70.0
   4 │    70.0     88.0     20.0     18.0     60.0     90.0     95.0     85.0

julia&gt; fns = makeminmax([maximum, maximum, maximum, maximum, maximum, maximum, maximum, maximum]);

julia&gt; result = moora(dmat, w, fns)

julia&gt; result.scores
4-element Array{Float64,1}:
 0.3315938731541169
 0.2901446390098523
 0.3730431072983815
 0.019265256092245782

julia&gt; result.bestIndex
4</code></pre><p><strong>References</strong></p><p>Celikbilek Yakup, Cok Kriterli Karar Verme Yontemleri, Aciklamali ve Karsilastirmali Saglik Bilimleri Uygulamalari ile. Editor: Muhlis Ozdemir, Nobel Kitabevi, Ankara, 2018</p><p>İşletmeciler, Mühendisler ve Yöneticiler için Operasyonel, Yönetsel ve Stratejik Problemlerin Çözümünde Çok Kriterli Karar verme Yöntemleri, Editörler: Bahadır Fatih Yıldırım ve Emrah Önder, Dora, 2. Basım, 2015, ISBN: 978-605-9929-44-8</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/fcfab8266915b131f587bf03a9a1e2b1bec357ac/src/moora.jl#L1-L60">source</a></section></article><h2 id="VIKOR"><a class="docs-heading-anchor" href="#VIKOR">VIKOR</a><a id="VIKOR-1"></a><a class="docs-heading-anchor-permalink" href="#VIKOR" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.vikor" href="#JMcDM.vikor"><code>JMcDM.vikor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    vikor(decisionMat, weights, fns; v = 0.5)</code></pre><p>Apply VIKOR (VlseKriterijumska Optimizcija I Kaompromisno Resenje in Serbian) method for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n candidate (or strategy) and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of function that are either maximum or minimum.</li><li><code>v::Float64</code>: Optional algorithm parameter. Default is 0.5.</li></ul><p><strong>Description</strong></p><p>vikor() applies the VIKOR method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::VikorResult</code>: VikorResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Amat = [
             100 92 10 2 80 70 95 80 ;
             80  70 8  4 100 80 80 90 ;
             90 85 5 0 75 95 70 70 ; 
             70 88 20 18 60 90 95 85
           ];

julia&gt; dmat = makeDecisionMatrix(Amat)
4×8 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4     Crt5     Crt6     Crt7     Crt8    
     │ Float64  Float64  Float64  Float64  Float64  Float64  Float64  Float64 
─────┼────────────────────────────────────────────────────────────────────────
   1 │   100.0     92.0     10.0      2.0     80.0     70.0     95.0     80.0
   2 │    80.0     70.0      8.0      4.0    100.0     80.0     80.0     90.0
   3 │    90.0     85.0      5.0      0.0     75.0     95.0     70.0     70.0
   4 │    70.0     88.0     20.0     18.0     60.0     90.0     95.0     85.0

julia&gt; fns = makeminmax([maximum, maximum, maximum, maximum, maximum, maximum, maximum, maximum]);

julia&gt; result = vikor(dmat, w, fns);

julia&gt; result.scores
4-element Array{Float64,1}:
  0.1975012087551764
  0.2194064473270817
  0.3507643203516215
 -0.16727341435277993

julia&gt; result.bestIndex
4
</code></pre><p><strong>References</strong></p><p>Celikbilek Yakup, Cok Kriterli Karar Verme Yontemleri, Aciklamali ve Karsilastirmali Saglik Bilimleri Uygulamalari ile. Editor: Muhlis Ozdemir, Nobel Kitabevi, Ankara, 2018</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/fcfab8266915b131f587bf03a9a1e2b1bec357ac/src/vikor.jl#L1-L56">source</a></section></article><h2 id="AHP"><a class="docs-heading-anchor" href="#AHP">AHP</a><a id="AHP-1"></a><a class="docs-heading-anchor-permalink" href="#AHP" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.ahp" href="#JMcDM.ahp"><code>JMcDM.ahp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">AHP(comparisonMatrix, criteriaComparisonMatrix)</code></pre><p>Apply AHP (Analytical Hierarchy Process) for a given comparison matrix and criteria comparison matrix.</p><p><strong>Arguments:</strong></p><ul><li><code>comparisonMatrix::DataFrame</code>: Comparison matrix for AHP (Comparison of rows). </li><li><code>criteriaComparisonMatrix::DataFrame</code>: Criteria comparison matrix for AHP (Comparison of columns). </li></ul><p><strong>Description</strong></p><p>AHP is based on subjective comparison between criteria. The success of the method highly depends on  consistency of these comparison. The method test the consistency first. At the next step, weights are  calculated. The ordering of rows is determined by these weights.</p><p><strong>Output</strong></p><ul><li><code>::AHPResult</code>: AhpResult object that holds multiple outputs including calculated weights and scores.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; K
8×8 Array{Float64,2}:
 1.0       7.0  0.2    0.125     0.5   0.333333  0.2       1.0
 0.142857  1.0  0.125  0.111111  0.25  0.2       0.111111  0.125
 5.0       8.0  1.0    0.333333  4.0   2.0       1.0       1.0
 8.0       9.0  3.0    1.0       7.0   5.0       3.0       3.0
 2.0       4.0  0.25   0.142857  1.0   0.5       0.2       0.2
 3.0       5.0  0.5    0.2       2.0   1.0       0.333333  0.333333
 5.0       9.0  1.0    0.333333  5.0   3.0       1.0       1.0
 1.0       8.0  1.0    0.333333  5.0   3.0       1.0       1.0

julia&gt; A1
4×4 Array{Float64,2}:
 1.0       3.0  0.2       2.0
 0.333333  1.0  0.142857  0.333333
 5.0       7.0  1.0       4.0
 0.5       3.0  0.25      1.0

julia&gt; A2
4×4 Array{Float64,2}:
 1.0   0.5       4.0       5.0
 2.0   1.0       6.0       7.0
 0.25  0.166667  1.0       3.0
 0.2   0.142857  0.333333  1.0

julia&gt; A3
4×4 Array{Float64,2}:
 1.0       0.5  0.166667  3.0
 2.0       1.0  0.25      5.0
 6.0       4.0  1.0       9.0
 0.333333  0.2  0.111111  1.0

julia&gt; A4
4×4 Array{Float64,2}:
 1.0       7.0  0.25      2.0
 0.142857  1.0  0.111111  0.2
 4.0       9.0  1.0       5.0
 0.5       5.0  0.2       1.0

julia&gt; A5
4×4 Array{Float64,2}:
 1.0       6.0  2.0   3.0
 0.166667  1.0  0.25  0.333333
 0.5       4.0  1.0   2.0
 0.333333  3.0  0.5   1.0

julia&gt; A6
4×4 Array{Float64,2}:
 1.0  0.25  0.5  0.142857
 4.0  1.0   2.0  0.333333
 2.0  0.5   1.0  0.2
 7.0  3.0   5.0  1.0

julia&gt; A7
4×4 Array{Float64,2}:
 1.0       3.0   7.0  1.0
 0.333333  1.0   4.0  0.333333
 0.142857  0.25  1.0  0.142857
 1.0       3.0   7.0  1.0

julia&gt; A8
4×4 Array{Float64,2}:
 1.0    2.0       5.0       8.0
 0.5    1.0       3.0       6.0
 0.2    0.333333  1.0       3.0
 0.125  0.166667  0.333333  1.0

julia&gt; km = makeDecisionMatrix(K);
julia&gt; as = map(makeDecisionMatrix, [A1, A2, A3, A4, A5, A6, A7, A8]);
julia&gt; result = ahp(as, km);
julia&gt; result.bestIndex
3
julia&gt; result.scores
4-element Array{Float64,1}:
 0.2801050163111839
 0.14822726478768022
 0.3813036392434616
 0.19036407965767424</code></pre><p><strong>References</strong></p><p>Saaty, Thomas L. &quot;Decision making with the analytic hierarchy process.&quot; International journal of services sciences 1.1 (2008): 83-98.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/fcfab8266915b131f587bf03a9a1e2b1bec357ac/src/ahp.jl#L134-L235">source</a></section></article><h2 id="Data-Envelopment-Analysis"><a class="docs-heading-anchor" href="#Data-Envelopment-Analysis">Data Envelopment Analysis</a><a id="Data-Envelopment-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Envelopment-Analysis" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>JMcDM.dataenvelop</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Grey-Relational-Analysis"><a class="docs-heading-anchor" href="#Grey-Relational-Analysis">Grey Relational Analysis</a><a id="Grey-Relational-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Grey-Relational-Analysis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.grey" href="#JMcDM.grey"><code>JMcDM.grey</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    grey(decisionMat, weights, fs, zeta)

Perform GRA (Grey Relational Analysis) for a given decision matrix and weights.</code></pre><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::Array{Float,2}</code>: n × m matrix of decision matrix. </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights for criteria.</li><li><code>fs::Array{Function, 1}</code>: m-vector of functions that are either maximize or minimize for each single criterion.</li><li><code>zeta::Float64</code>: zeta parameter for the algorithm. The default is 0.5.</li></ul><p><strong>Description</strong></p><p>Applies GRA (Grey Relational Analysis).</p><p><strong>Output</strong></p><ul><li><code>::GameResult</code>: GreyResult object that holds many values including ordering of strategies or candidates and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; # Decision matrix of 5 candidates and 6 criteria.
julia&gt; df = DataFrame(
               :K1 =&gt; [105000.0, 120000, 150000, 115000, 135000],
               :K2 =&gt; [105.0, 110, 120, 105, 115],
               :K3 =&gt; [10.0, 15, 12, 20, 15],
               :K4 =&gt; [4.0, 4, 3, 4, 5],
               :K5 =&gt; [300.0, 500, 550, 600, 400],
               :K6 =&gt; [10.0, 8, 12, 9, 9]
        )
5×6 DataFrame
 Row │ K1        K2       K3       K4       K5       K6      
     │ Float64   Float64  Float64  Float64  Float64  Float64 
─────┼───────────────────────────────────────────────────────
   1 │ 105000.0    105.0     10.0      4.0    300.0     10.0
   2 │ 120000.0    110.0     15.0      4.0    500.0      8.0
   3 │ 150000.0    120.0     12.0      3.0    550.0     12.0
   4 │ 115000.0    105.0     20.0      4.0    600.0      9.0
   5 │ 135000.0    115.0     15.0      5.0    400.0      9.0

julia&gt; # Direction of optimization for each single criterion
julia&gt; functionlist = [minimum, maximum, minimum, maximum, maximum, minimum];

julia&gt; # Weights
julia&gt; w = [0.05, 0.20, 0.10, 0.15, 0.10, 0.40];

julia&gt; result = grey(df, w, functionlist);

julia&gt; result.scores
5-element Array{Float64,1}:
 0.525
 0.7007142857142857
 0.5464285714285715
 0.5762820512820512
 0.650952380952381

julia&gt; result.bestIndex
2</code></pre><p><strong>References</strong></p><p>İşletmeciler, Mühendisler ve Yöneticiler için Operasyonel, Yönetsel ve Stratejik Problemlerin Çözümünde Çok Kriterli Karar verme Yöntemleri, Editörler: Bahadır Fatih Yıldırım ve Emrah Önder, Dora, 2. Basım, 2015, ISBN: 978-605-9929-44-8</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/fcfab8266915b131f587bf03a9a1e2b1bec357ac/src/grey.jl#L1-L63">source</a></section></article><h2 id="Non-dominated-Sorting"><a class="docs-heading-anchor" href="#Non-dominated-Sorting">Non-dominated Sorting</a><a id="Non-dominated-Sorting-1"></a><a class="docs-heading-anchor-permalink" href="#Non-dominated-Sorting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.nds" href="#JMcDM.nds"><code>JMcDM.nds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nds(data)

Sort multidimensional data using non-dominated sorting algorithm.</code></pre><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: n x k desicion matrix with n cases and k critera.</li></ul><p><strong>Output</strong></p><ul><li><code>::NDSResult</code>: NDSResult object that holds multiple outputs including ranks and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl"> julia&gt; cases = [
               1.0 2.0 3.0;
               2.0 1.0 3.0;
               1.0 3.0 2.0;
               4.0 5.0 6.0
           ];

julia&gt; nd = makeDecisionMatrix(cases)
4×3 DataFrame
 Row │ Crt1     Crt2     Crt3    
     │ Float64  Float64  Float64 
─────┼───────────────────────────
   1 │     1.0      2.0      3.0
   2 │     2.0      1.0      3.0
   3 │     1.0      3.0      2.0
   4 │     4.0      5.0      6.0

julia&gt; result = nds(nd);

julia&gt; result.ranks
4-element Array{Int64,1}:
 0
 0
 0
 3

julia&gt; result.bestIndex
4 </code></pre><p><strong>References</strong></p><p>Deb, Kalyanmoy, et al. &quot;A fast elitist non-dominated sorting genetic algorithm for multi-objective optimization: NSGA-II.&quot;  International conference on parallel problem solving from nature. Springer, Berlin, Heidelberg, 2000.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/fcfab8266915b131f587bf03a9a1e2b1bec357ac/src/nds.jl#L92-L139">source</a></section></article><h2 id="SAW"><a class="docs-heading-anchor" href="#SAW">SAW</a><a id="SAW-1"></a><a class="docs-heading-anchor-permalink" href="#SAW" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.saw" href="#JMcDM.saw"><code>JMcDM.saw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    saw(decisionMat, weights, fns)</code></pre><p>Apply SAW (Simple Additive Weighting) method for a given matrix and weights. This method also known as WSM (Weighted Sum Model)</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n candidate (or strategy) and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of functions to be applied on the columns. </li></ul><p><strong>Description</strong></p><p>saw() applies the SAW method to rank n strategies subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::SawResult</code>: SawResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; decmat = [4.0  7  3  2  2  2  2;
                 4.0  4  6  4  4  3  7;
                 7.0  6  4  2  5  5  3;
                 3.0  2  5  3  3  2  5;
                 4.0  2  2  5  5  3  6];
julia&gt; df = makeDecisionMatrix(decmat)
5×7 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4     Crt5     Crt6     Crt7    
     │ Float64  Float64  Float64  Float64  Float64  Float64  Float64 
─────┼───────────────────────────────────────────────────────────────
   1 │     4.0      7.0      3.0      2.0      2.0      2.0      2.0
   2 │     4.0      4.0      6.0      4.0      4.0      3.0      7.0
   3 │     7.0      6.0      4.0      2.0      5.0      5.0      3.0
   4 │     3.0      2.0      5.0      3.0      3.0      2.0      5.0
   5 │     4.0      2.0      2.0      5.0      5.0      3.0      6.0

julia&gt; fns = convert(Array{Function,1}, [maximum for i in 1:7])
7-element Array{Function,1}:
 maximum (generic function with 16 methods)
 maximum (generic function with 16 methods)
 maximum (generic function with 16 methods)
 maximum (generic function with 16 methods)
 maximum (generic function with 16 methods)
 maximum (generic function with 16 methods)
 maximum (generic function with 16 methods)

julia&gt; weights = [0.283, 0.162, 0.162, 0.07, 0.085, 0.162, 0.076];

julia&gt; result = saw(df, weights, fns);

julia&gt; result.scores
5-element Array{Float64,1}:
 0.5532285714285714
 0.7134857142857142
 0.8374285714285714
 0.5146571428571429
 0.5793428571428572

julia&gt; result.bestIndex
3</code></pre><p><strong>References</strong></p><p>Afshari, Alireza, Majid Mojahed, and Rosnah Mohd Yusuff. &quot;Simple additive weighting approach to  personnel selection problem.&quot; International Journal of Innovation, Management and Technology  1.5 (2010): 511.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/fcfab8266915b131f587bf03a9a1e2b1bec357ac/src/saw.jl#L1-L66">source</a></section></article><h2 id="ARAS"><a class="docs-heading-anchor" href="#ARAS">ARAS</a><a id="ARAS-1"></a><a class="docs-heading-anchor-permalink" href="#ARAS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.aras" href="#JMcDM.aras"><code>JMcDM.aras</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">aras(decisionMat, weights, fs)</code></pre><p>Apply ARAS (Additive Ratio ASsessment) method for a given matrix, weights and, type of criteria.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fs::Array{Function,1}</code>: m-vector of type of criteria. The benefit criteria shown with &quot;maximum&quot;, and the cost criteria shown with &quot;minimum&quot;.</li></ul><p><strong>Description</strong></p><p>aras() applies the ARAS method to rank n alternatives subject to m criteria and criteria type vector.</p><p><strong>Output</strong></p><ul><li><code>::ARASResult</code>: ARASResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; df = DataFrame(
    :K1 =&gt; [105000.0, 120000, 150000, 115000, 135000],
    :K2 =&gt; [105.0, 110, 120, 105, 115],
    :K3 =&gt; [10.0, 15, 12, 20, 15],
    :K4 =&gt; [4.0, 4, 3, 4, 5],
    :K5 =&gt; [300.0, 500, 550, 600, 400],
    :K6 =&gt; [10.0, 8, 12, 9, 9]
)
julia&gt; df
5×6 DataFrame
 Row │ K1        K2       K3       K4       K5       K6      
     │ Float64   Float64  Float64  Float64  Float64  Float64 
─────┼───────────────────────────────────────────────────────
   1 │ 105000.0    105.0     10.0      4.0    300.0     10.0
   2 │ 120000.0    110.0     15.0      4.0    500.0      8.0
   3 │ 150000.0    120.0     12.0      3.0    550.0     12.0
   4 │ 115000.0    105.0     20.0      4.0    600.0      9.0
   5 │ 135000.0    115.0     15.0      5.0    400.0      9.0
julia&gt; result = aras(df, w, fs);
julia&gt; result.bestIndex
2
julia&gt; result.scores
5-element Array{Float64,1}:
 0.8142406768388222
 0.8928861957614441
 0.764157900073527
 0.8422546181927358
 0.8654063509472654</code></pre><p><strong>References</strong></p><p>Zavadskas, E. K., &amp; Turskis, Z. (2010). A new additive ratio assessment (ARAS) method in multicriteria decision‐making. Technological and Economic Development of Economy, 16(2), 159-172. Yıldırım, B. F. (2015). &quot;Çok Kriterli Karar Verme Problemlerinde ARAS Yöntemi&quot;. Kafkas Üniversitesi İktisadi ve İdari Bilimler Fakültesi Dergisi, 6 (9), 285-296. http://dx.doi.org/10.18025/kauiibf.65151</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/fcfab8266915b131f587bf03a9a1e2b1bec357ac/src/aras.jl#L1-L46">source</a></section></article><h2 id="WPM"><a class="docs-heading-anchor" href="#WPM">WPM</a><a id="WPM-1"></a><a class="docs-heading-anchor-permalink" href="#WPM" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.wpm" href="#JMcDM.wpm"><code>JMcDM.wpm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    wpm(decisionMat, weights, fns)</code></pre><p>Apply WPM (Weighted Product Method) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alterntives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of functions to be applied on the columns. </li></ul><p><strong>Description</strong></p><p>wpm() applies the WPM method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::WPMResult</code>: WPMResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; decmat = [3        12.5        2        120        14        3;
       5        15        3        110        38        4;
       3        13        2        120        19        3;
       4        14        2        100        31        4;
       3        15        1.5        125        40        4]
5×6 Array{Float64,2}:
 3.0  12.5  2.0  120.0  14.0  3.0
 5.0  15.0  3.0  110.0  38.0  4.0
 3.0  13.0  2.0  120.0  19.0  3.0
 4.0  14.0  2.0  100.0  31.0  4.0
 3.0  15.0  1.5  125.0  40.0  4.0

julia&gt; df = makeDecisionMatrix(decmat)
5×6 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4     Crt5     Crt6    
     │ Float64  Float64  Float64  Float64  Float64  Float64 
─────┼──────────────────────────────────────────────────────
   1 │     3.0     12.5      2.0    120.0     14.0      3.0
   2 │     5.0     15.0      3.0    110.0     38.0      4.0
   3 │     3.0     13.0      2.0    120.0     19.0      3.0
   4 │     4.0     14.0      2.0    100.0     31.0      4.0
   5 │     3.0     15.0      1.5    125.0     40.0      4.0

julia&gt; weights = [0.221, 0.159, 0.175, 0.127, 0.117, 0.201];

julia&gt; fns = [maximum, minimum, minimum, maximum, minimum, maximum];

julia&gt; result = wpm(df, weights, fns);

julia&gt; result.scores
5-element Array{Float64,1}:
 0.7975224331331252
 0.7532541470584717
 0.7647463553356331
 0.7873956894790834
 0.7674278741781709

julia&gt; result.bestIndex
1</code></pre><p><strong>References</strong></p><p>Zavadskas, E. K., Turskis, Z., Antucheviciene, J., &amp; Zakarevicius, A. (2012). Optimization of Weighted Aggregated Sum Product Assessment. Elektronika Ir Elektrotechnika, 122(6), 3-6. https://doi.org/10.5755/j01.eee.122.6.1810</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/fcfab8266915b131f587bf03a9a1e2b1bec357ac/src/wpm.jl#L1-L63">source</a></section></article><h2 id="WASPAS"><a class="docs-heading-anchor" href="#WASPAS">WASPAS</a><a id="WASPAS-1"></a><a class="docs-heading-anchor-permalink" href="#WASPAS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.waspas" href="#JMcDM.waspas"><code>JMcDM.waspas</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    waspas(decisionMat, weights, fns, lambda)</code></pre><p>Apply WASPAS (Weighted Aggregated Sum Product ASsessment ) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alterntives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of functions to be applied on the columns.</li><li><code>lambda::Float64</code>: joint criterion. 0&lt;=lambda&lt;=1, default=0.5.</li></ul><p><strong>Description</strong></p><p>waspas() applies the WASPAS method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::WASPASResult</code>: WASPASResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; decmat = [3        12.5        2        120        14        3;
       5        15        3        110        38        4;
       3        13        2        120        19        3;
       4        14        2        100        31        4;
       3        15        1.5        125        40        4]
5×6 Array{Float64,2}:
 3.0  12.5  2.0  120.0  14.0  3.0
 5.0  15.0  3.0  110.0  38.0  4.0
 3.0  13.0  2.0  120.0  19.0  3.0
 4.0  14.0  2.0  100.0  31.0  4.0
 3.0  15.0  1.5  125.0  40.0  4.0

julia&gt; df = makeDecisionMatrix(decmat)
5×6 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4     Crt5     Crt6    
     │ Float64  Float64  Float64  Float64  Float64  Float64 
─────┼──────────────────────────────────────────────────────
   1 │     3.0     12.5      2.0    120.0     14.0      3.0
   2 │     5.0     15.0      3.0    110.0     38.0      4.0
   3 │     3.0     13.0      2.0    120.0     19.0      3.0
   4 │     4.0     14.0      2.0    100.0     31.0      4.0
   5 │     3.0     15.0      1.5    125.0     40.0      4.0

julia&gt; weights = [0.221, 0.159, 0.175, 0.127, 0.117, 0.201];

julia&gt; fns = [maximum, minimum, minimum, maximum, minimum, maximum];

julia&gt; lambda = 0.5;

julia&gt; result = wpm(df, weights, fns, lambda);

julia&gt; result.scores
5-element Array{Float64,1}:
 0.8050212165665626
 0.7750597051081832
 0.770180748518019
 0.7964243424353943
 0.7882389370890854

 julia&gt; result.bestIndex
 1</code></pre><p><strong>References</strong></p><p>Zavadskas, E. K., Turskis, Z., Antucheviciene, J., &amp; Zakarevicius, A. (2012). Optimization of Weighted Aggregated Sum Product Assessment. Elektronika Ir Elektrotechnika, 122(6), 3-6. https://doi.org/10.5755/j01.eee.122.6.1810 Aytaç Adalı, E. &amp; Tuş Işık, A.. (2017). Bir Tedarikçi Seçim Problemi İçin SWARA ve WASPAS Yöntemlerine Dayanan Karar Verme Yaklaşımı. International Review of Economics and Management, 5 (4) , 56-77. DOI: 10.18825/iremjournal.335408</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/fcfab8266915b131f587bf03a9a1e2b1bec357ac/src/waspas.jl#L1-L67">source</a></section></article><h2 id="EDAS"><a class="docs-heading-anchor" href="#EDAS">EDAS</a><a id="EDAS-1"></a><a class="docs-heading-anchor-permalink" href="#EDAS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.edas" href="#JMcDM.edas"><code>JMcDM.edas</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    edas(decisionMat, weights, fns)</code></pre><p>Apply EDAS (Evaluation based on Distance from Average Solution) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alterntives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of functions to be applied on the columns. </li></ul><p><strong>Description</strong></p><p>edas() applies the EDAS method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::EDASResult</code>: EDASResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; decmat = [5000 5 5300 450;
       4500 5 5000 400;
       4500 4 4700 400;
       4000 4 4200 400;
       5000 4 7100 500;
       5000 5 5400 450;
       5500 5 6200 500;
       5000 4 5800 450]
8×4 Array{Int64,2}:
 5000  5  5300  450
 4500  5  5000  400
 4500  4  4700  400
 4000  4  4200  400
 5000  4  7100  500
 5000  5  5400  450
 5500  5  6200  500
 5000  4  5800  450

julia&gt; df = makeDecisionMatrix(decmat)
8×4 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4    
     │ Float64  Float64  Float64  Float64 
─────┼────────────────────────────────────
   1 │  5000.0      5.0   5300.0    450.0
   2 │  4500.0      5.0   5000.0    400.0
   3 │  4500.0      4.0   4700.0    400.0
   4 │  4000.0      4.0   4200.0    400.0
   5 │  5000.0      4.0   7100.0    500.0
   6 │  5000.0      5.0   5400.0    450.0
   7 │  5500.0      5.0   6200.0    500.0
   8 │  5000.0      4.0   5800.0    450.0

julia&gt; weights = [0.25, 0.25, 0.25, 0.25];

julia&gt; fns = [maximum, maximum, minimum, minimum];

julia&gt; result = edas(df, weights, fns);

julia&gt; result.scores
8-element Array{Float64,1}:
 0.7595941163602383
 0.8860162461306114
 0.6974721951442592
 0.739657763190231
 0.05908329207449442
 0.7318326305342363
 0.6416913873322523
 0.38519414045559647

julia&gt; result.bestIndex
2</code></pre><p><strong>References</strong></p><p>Keshavarz Ghorabaee, M., Zavadskas, E. K., Olfat, L., &amp; Turskis, Z. (2015). Multi-criteria inventory classification using a new method of evaluation based on distance from average solution (EDAS). Informatica, 26(3), 435-451.</p><p>Ulutaş, A. (2017). EDAS Yöntemi Kullanılarak Bir Tekstil Atölyesi İçin Dikiş Makinesi Seçimi. İşletme Araştırmaları Dergisi, 9(2), 169-183.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/fcfab8266915b131f587bf03a9a1e2b1bec357ac/src/edas.jl#L1-L79">source</a></section></article><h2 id="MARCOS"><a class="docs-heading-anchor" href="#MARCOS">MARCOS</a><a id="MARCOS-1"></a><a class="docs-heading-anchor-permalink" href="#MARCOS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.marcos" href="#JMcDM.marcos"><code>JMcDM.marcos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    marcos(decisionMat, weights, fns)</code></pre><p>Apply MARCOS (Measurement Alternatives and Ranking according to COmpromise Solution) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alterntives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of functions to be applied on the columns. </li></ul><p><strong>Description</strong></p><p>marcos() applies the MARCOS method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MARCOSResult</code>: MARCOSResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; decmat = [8.675 8.433 8.000 7.800 8.025 8.043;
       8.825 8.600 7.420 7.463 7.825 8.229;
       8.325 7.600 8.040 7.700 7.925 7.600;
       8.525 8.667 7.180 7.375 7.750 8.071]
4×6 Array{Float64,2}:
 8.675  8.433  8.0   7.8    8.025  8.043
 8.825  8.6    7.42  7.463  7.825  8.229
 8.325  7.6    8.04  7.7    7.925  7.6
 8.525  8.667  7.18  7.375  7.75   8.071

julia&gt; df = makeDecisionMatrix(decmat)

4×6 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4     Crt5     Crt6    
     │ Float64  Float64  Float64  Float64  Float64  Float64 
─────┼──────────────────────────────────────────────────────
   1 │   8.675    8.433     8.0     7.8      8.025    8.043
   2 │   8.825    8.6       7.42    7.463    7.825    8.229
   3 │   8.325    7.6       8.04    7.7      7.925    7.6
   4 │   8.525    8.667     7.18    7.375    7.75     8.071

julia&gt; weights = [0.1901901901901902 , 0.15915915915915918 , 0.19819819819819823, 0.1901901901901902, 0.15115115115115116, 0.11111111111111112];

julia&gt; fns = [maximum, maximum, maximum, maximum, maximum, maximum];

julia&gt; Fns = convert(Array{Function, 1} , fns)

julia&gt; result = marcos(df, weights, Fns);

julia&gt; result.scores
4-element Array{Float64,1}:
 0.6848657890705123
 0.6727670074308345
 0.6625969531206817
 0.6611030275027843

julia&gt; result.bestIndex
1</code></pre><p><strong>References</strong></p><p>Stević, Z., Pamučar, D., Puška, A., Chatterjee, P., Sustainable supplier selection in healthcare industries using a new MCDM method: Measurement Alternatives and Ranking according to COmpromise Solution (MARCOS), Computers &amp; Industrial Engineering (2019), doi: https://doi.org/10.1016/j.cie.2019.106231</p><p>Puška, A., Stojanović, I., Maksimović, A., &amp; Osmanović, N. (2020). Evaluation software of project management used measurement of alternatives and ranking according to compromise solution (MARCOS) method. Operational Research in Engineering Sciences: Theory and Applications, 3(1), 89-102.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/fcfab8266915b131f587bf03a9a1e2b1bec357ac/src/marcos.jl#L1-L64">source</a></section></article><h2 id="MABAC"><a class="docs-heading-anchor" href="#MABAC">MABAC</a><a id="MABAC-1"></a><a class="docs-heading-anchor-permalink" href="#MABAC" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.mabac" href="#JMcDM.mabac"><code>JMcDM.mabac</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    mabac(decisionMat, weights, fns)</code></pre><p>Apply MABAC (Multi-Attributive Border Approximation area Comparison) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of functions to be applied on the columns. </li></ul><p><strong>Description</strong></p><p>mabac() applies the MABAC method to rank n alternatives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MABACResult</code>: MABACResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; decmat = [2 1 4 7 6 6 7 3000;
       4 1 5 6 7 7 6 3500;
       3 2 6 6 5 6 8 4000;
       5 1 5 7 6 7 7 3000;
       4 2 5 6 7 7 6 3000;
       3 2 6 6 6 6 6 3500]
6×8 
Array{Int64,2}:
 2  1  4  7  6  6  7  3000
 4  1  5  6  7  7  6  3500
 3  2  6  6  5  6  8  4000
 5  1  5  7  6  7  7  3000
 4  2  5  6  7  7  6  3000
 3  2  6  6  6  6  6  3500

julia&gt; df = makeDecisionMatrix(decmat)
6×8 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4     Crt5     Crt6     Crt7     Crt8    
     │ Float64  Float64  Float64  Float64  Float64  Float64  Float64  Float64 
─────┼────────────────────────────────────────────────────────────────────────
   1 │     2.0      1.0      4.0      7.0      6.0      6.0      7.0   3000.0
   2 │     4.0      1.0      5.0      6.0      7.0      7.0      6.0   3500.0
   3 │     3.0      2.0      6.0      6.0      5.0      6.0      8.0   4000.0
   4 │     5.0      1.0      5.0      7.0      6.0      7.0      7.0   3000.0
   5 │     4.0      2.0      5.0      6.0      7.0      7.0      6.0   3000.0
   6 │     3.0      2.0      6.0      6.0      6.0      6.0      6.0   3500.0

julia&gt; weights = [0.293, 0.427, 0.067, 0.027, 0.053, 0.027, 0.053, 0.053];

julia&gt; fns = [maximum, maximum, maximum, maximum, maximum, maximum, maximum, minimum];

julia&gt; result = mabac(df, weights, fns);

julia&gt; result.scores
6-element Array{Float64,1}:
 -0.3113160790692055
 -0.10898274573587217
  0.2003505875974611
  0.0421839209307945
  0.3445172542641278
  0.2003505875974611

julia&gt; result.bestIndex
5</code></pre><p><strong>References</strong></p><p>Pamučar, D., &amp; Ćirović, G. (2015). The selection of transport and handling resources in logistics centers using Multi-Attributive Border Approximation area Comparison (MABAC). Expert Systems with Applications, 42(6), 3016–3028. doi:10.1016/j.eswa.2014.11.057</p><p>Ulutaş, A. (2019). Entropi ve MABAC yöntemleri ile personel seçimi. OPUS–International Journal of Society Researches, 13(19), 1552-1573. DOI: 10.26466/opus.580456</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/fcfab8266915b131f587bf03a9a1e2b1bec357ac/src/mabac.jl#L1-L71">source</a></section></article><h2 id="MAIRCA"><a class="docs-heading-anchor" href="#MAIRCA">MAIRCA</a><a id="MAIRCA-1"></a><a class="docs-heading-anchor-permalink" href="#MAIRCA" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.mairca" href="#JMcDM.mairca"><code>JMcDM.mairca</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    mairca(decisionMat, weights, fns)</code></pre><p>Apply MAIRCA (Multi Attributive Ideal-Real Comparative Analysis) for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of functions to be applied on the columns. </li></ul><p><strong>Description</strong></p><p>mairca() applies the MAIRCA method to rank n alternatives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::MAIRCAResult</code>: MAIRCAResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; decmat = [6.952 8.000 6.649 7.268 8.000 7.652 6.316;
       7.319 7.319 6.604 7.319 8.000 7.652 5.313;
       7.000 7.319 7.652 6.952 7.652 6.952 4.642;
       7.319 6.952 6.649 7.319 7.652 6.649 5.000]
4×7 Array{Float64,2}:
 6.952  8.0    6.649  7.268  8.0    7.652  6.316
 7.319  7.319  6.604  7.319  8.0    7.652  5.313
 7.0    7.319  7.652  6.952  7.652  6.952  4.642
 7.319  6.952  6.649  7.319  7.652  6.649  5.0

 julia&gt; df = makeDecisionMatrix(decmat)
 4×7 DataFrame
  Row │ Crt1     Crt2     Crt3     Crt4     Crt5     Crt6     Crt7    
      │ Float64  Float64  Float64  Float64  Float64  Float64  Float64 
 ─────┼───────────────────────────────────────────────────────────────
    1 │   6.952    8.0      6.649    7.268    8.0      7.652    6.316
    2 │   7.319    7.319    6.604    7.319    8.0      7.652    5.313
    3 │   7.0      7.319    7.652    6.952    7.652    6.952    4.642
    4 │   7.319    6.952    6.649    7.319    7.652    6.649    5.0

julia&gt; weights = [0.172, 0.165, 0.159, 0.129, 0.112, 0.122, 0.140];

julia&gt; fns = [maximum, maximum, maximum, maximum, maximum, maximum, minimum];

julia&gt; result = mairca(df, weights, fns);

julia&gt; result.scores
4-element Array{Float64,1}:
 0.12064543054088471
 0.08066456363291889
 0.14586265389012484
 0.14542366685864686

julia&gt; result.bestIndex
2</code></pre><p><strong>References</strong></p><p>Pamučar, D., Lukovac, V., Božanić, D., &amp; Komazec, N. (2018). Multi-criteria FUCOM-MAIRCA model for the evaluation of level crossings: case study in the Republic of Serbia. Operational Research in Engineering Sciences: Theory and Applications, 1(1), 108-129.</p><p>Ulutaş A.(2019),Swara Ve Mairca Yöntemleri İle Catering Firması Seçimi,BMIJ, (2019), 7(4): 1467-1479 http://dx.doi.org/10.15295/bmij.v7i4.1166</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/fcfab8266915b131f587bf03a9a1e2b1bec357ac/src/mairca.jl#L1-L62">source</a></section></article><h2 id="COPRAS"><a class="docs-heading-anchor" href="#COPRAS">COPRAS</a><a id="COPRAS-1"></a><a class="docs-heading-anchor-permalink" href="#COPRAS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.copras" href="#JMcDM.copras"><code>JMcDM.copras</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">copras(decisionMat, weights, fs)</code></pre><p>Apply COPRAS (COmplex PRoportional ASsesment) method for a given matrix, weights and, type of criteria.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fs::Array{Function,1}</code>: m-vector of type of criteria. The benefit criteria shown with &quot;maximum&quot;, and the cost criteria shown with &quot;minimum&quot;.</li></ul><p><strong>Description</strong></p><p>copras() applies the COPRAS method to rank n alternatives subject to m criteria and criteria type vector.</p><p><strong>Output</strong></p><ul><li><code>::COPRASResult</code>: COPRASResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; decmat = [2.50 240 57 45 1.10 0.333333;
       2.50 285 60 75 4.00 0.428571;
       4.50 320 100 65 7.50 1.111111;
       4.50 365 100 90 7.50 1.111111;
       5.00 400 100 90 11.00 1.111111;
       2.50 225 60 45 1.10 0.333333;
       2.50 270 57 60 4.00 0.428571;
       4.50 330 100 70 7.50 1.111111;
       4.50 365 100 80 7.50 1.111111;
       5.00 380 110 65 8.00 1.111111;
       2.50 285 65 80 4.00 0.400000;
       4.00 280 75 65 4.00 0.400000;
       4.50 365 102 95 7.50 1.111111;
       4.50 400 102 95 7.50 1.111111;
       6.00 450 110 95 11.00 1.176471;
       6.00 510 110 105 11.00 1.176471;
       6.00 330 140 110 18.50 1.395349;
       2.50 240 65 80 4.00 0.400000;
       4.00 280 75 75 4.00 0.400000;
       4.50 355 102 95 7.50 1.111111;
       4.50 385 102 90 7.50 1.111111;
       5.00 385 114 95 7.50 1.000000;
       6.00 400 110 90 11.00 1.000000;
       6.00 480 110 95 15.00 1.000000;
       6.00 440 140 100 18.50 1.200000;
       6.00 500 140 100 18.50 1.200000;
       5.00 450 125 100 15.00 1.714286;
       6.00 500 150 125 18.50 1.714286;
       6.00 515 180 140 22.00 2.307692;
       7.00 550 200 150 30.00 2.307692;
       6.00 500 180 140 15.00 2.307692;
       6.00 500 180 140 18.50 2.307692;
       6.00 500 180 140 22.00 2.307692;
       7.00 500 180 140 30.00 2.307692;
       7.00 500 200 140 37.00 2.307692;
       7.00 500 200 140 45.00 2.307692;
       7.00 500 200 140 55.00 2.307692;
       7.00 500 200 140 75.00 2.307692]
38×6 Array{Float64,2}:
 2.5  240.0   57.0   45.0   1.1  0.333333
 2.5  285.0   60.0   75.0   4.0  0.428571
 4.5  320.0  100.0   65.0   7.5  1.11111
 4.5  365.0  100.0   90.0   7.5  1.11111
 5.0  400.0  100.0   90.0  11.0  1.11111
 2.5  225.0   60.0   45.0   1.1  0.333333
 2.5  270.0   57.0   60.0   4.0  0.428571
 4.5  330.0  100.0   70.0   7.5  1.11111
 4.5  365.0  100.0   80.0   7.5  1.11111
 5.0  380.0  110.0   65.0   8.0  1.11111
 2.5  285.0   65.0   80.0   4.0  0.4
 ⋮                               ⋮
 6.0  500.0  150.0  125.0  18.5  1.71429
 6.0  515.0  180.0  140.0  22.0  2.30769
 7.0  550.0  200.0  150.0  30.0  2.30769
 6.0  500.0  180.0  140.0  15.0  2.30769
 6.0  500.0  180.0  140.0  18.5  2.30769
 6.0  500.0  180.0  140.0  22.0  2.30769
 7.0  500.0  180.0  140.0  30.0  2.30769
 7.0  500.0  200.0  140.0  37.0  2.30769
 7.0  500.0  200.0  140.0  45.0  2.30769
 7.0  500.0  200.0  140.0  55.0  2.30769
 7.0  500.0  200.0  140.0  75.0  2.30769

julia&gt; df = makeDecisionMatrix(decmat)
38×6 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4     Crt5     Crt6     
     │ Float64  Float64  Float64  Float64  Float64  Float64  
─────┼───────────────────────────────────────────────────────
   1 │     2.5    240.0     57.0     45.0      1.1  0.333333
   2 │     2.5    285.0     60.0     75.0      4.0  0.428571
   3 │     4.5    320.0    100.0     65.0      7.5  1.11111
   4 │     4.5    365.0    100.0     90.0      7.5  1.11111
   5 │     5.0    400.0    100.0     90.0     11.0  1.11111
   6 │     2.5    225.0     60.0     45.0      1.1  0.333333
   7 │     2.5    270.0     57.0     60.0      4.0  0.428571
   8 │     4.5    330.0    100.0     70.0      7.5  1.11111
   9 │     4.5    365.0    100.0     80.0      7.5  1.11111
  ⋮  │    ⋮        ⋮        ⋮        ⋮        ⋮        ⋮
  30 │     7.0    550.0    200.0    150.0     30.0  2.30769
  31 │     6.0    500.0    180.0    140.0     15.0  2.30769
  32 │     6.0    500.0    180.0    140.0     18.5  2.30769
  33 │     6.0    500.0    180.0    140.0     22.0  2.30769
  34 │     7.0    500.0    180.0    140.0     30.0  2.30769
  35 │     7.0    500.0    200.0    140.0     37.0  2.30769
  36 │     7.0    500.0    200.0    140.0     45.0  2.30769
  37 │     7.0    500.0    200.0    140.0     55.0  2.30769
  38 │     7.0    500.0    200.0    140.0     75.0  2.30769
                                              20 rows omitted

julia&gt; weights = [0.1667, 0.1667, 0.1667, 0.1667, 0.1667, 0.1667];

julia&gt; fns = [maximum, maximum, maximum, maximum, maximum, minimum];

julia&gt; result = copras(df, w, fs);

julia&gt; result.bestIndex
38

julia&gt; result.scores
38-element Array{Float64,1}:
 0.021727395411605937
 0.019814414550092637
 0.01789214190869233
 0.01624057709923278
 0.01507318798582843
 0.021837811311495522
 0.020735423365838293
 0.01754833367014725
 0.016658288043259514
 0.016258710042371068
 0.019388734250223458
 ⋮
 0.01064826476628102
 0.01000964101170639
 0.007056714858865703
 0.010627520153194962
 0.010419795157349462
 0.010212070161503961
 0.00876261130160425
 0.007733739643860005
 0.007258939653356005
 0.006665439665226005
 0.005478439688966004</code></pre><p><strong>References</strong></p><p>Kaklauskas, A., Zavadskas, E. K., Raslanas, S., Ginevicius, R., Komka, A., &amp; Malinauskas, P. (2006). Selection of low-e windows in retrofit of public buildings by applying multiple criteria method COPRAS: A Lithuanian case. Energy and buildings, 38(5), 454-462. Özdağoğlu, A. (2013). İmalat işletmeleri için eksantrik pres alternatiflerinin COPRAS yöntemi ile karşılaştırılması. Gümüşhane Üniversitesi Sosyal Bilimler Enstitüsü Elektronik Dergisi, 4(8), 1-22. Yıldırım, B. F., Timor, M. (2019). &quot;Bulanık ve Gri COPRAS Yöntemleri Kullanılarak Tedarikçi Seçim Modeli Geliştirilmesi&quot;. Optimum Ekonomi ve Yönetim Bilimleri Dergisi, 6 (2), 283-310.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/fcfab8266915b131f587bf03a9a1e2b1bec357ac/src/copras.jl#L1-L142">source</a></section></article><h2 id="PROMETHEE"><a class="docs-heading-anchor" href="#PROMETHEE">PROMETHEE</a><a id="PROMETHEE-1"></a><a class="docs-heading-anchor-permalink" href="#PROMETHEE" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.promethee" href="#JMcDM.promethee"><code>JMcDM.promethee</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    promethee(decisionMatrix, prefs, weights, fns, qs, ps)</code></pre><p>Apply PROMETHEE (Preference Ranking Organization METHod for Enrichment of Evaluations) method for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMatrix::DataFrame</code>: n × m matrix of objective values for n candidate (or strategy) and m criteria </li><li><code>pref::Array{Function, 1}</code>: m-vector of preference functions that are prometLinear, prometVShape, prometUShape, prometQuasi, or prometLevel.</li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of functions that are either maximum or minimum.</li><li><code>qs::Array{Float64, 1}</code>: m-vector of q parameters that is used in corresponding preference function.</li><li><code>ps::Array{Float64, 1}</code>: m-vector of p parameters that is used in corresponding preference function</li></ul><p><strong>Description</strong></p><p>promethee() applies the PROMETHEE method to rank n strategies subject to m criteria which are supposed to be either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::Result</code>: PrometheeResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; decmat = [42.0 35 43 51; 
                     89 72 92 85;
                     14 85 17 40;
                     57 60 45 80;
                     48 32 43 40;
                     71 45 60 85;
                     69 40 72 55;
                     64 35 70 60];

julia&gt; df = makeDecisionMatrix(decmat)
8×4 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4    
     │ Float64  Float64  Float64  Float64 
─────┼────────────────────────────────────
   1 │    42.0     35.0     43.0     51.0
   2 │    89.0     72.0     92.0     85.0
   3 │    14.0     85.0     17.0     40.0
   4 │    57.0     60.0     45.0     80.0
   5 │    48.0     32.0     43.0     40.0
   6 │    71.0     45.0     60.0     85.0
   7 │    69.0     40.0     72.0     55.0
   8 │    64.0     35.0     70.0     60.0

julia&gt; qs = [49, nothing, 45, 30];

julia&gt; ps = [100, 98, 95, 80];

julia&gt; weights = [0.25, 0.35, 0.22, 0.18];

julia&gt; fns = makeminmax([maximum, maximum, maximum, maximum]);

julia&gt; prefs = convert(Array{Function,1}, [prometLinear, prometVShape, prometLinear, prometLinear]);

julia&gt; result = promethee(df, prefs, weights, fns, qs, ps);

julia&gt; result.scores
8-element Array{Float64,1}:
  0.0698938775510204
 -0.148590956382553
 -0.061361984793917565
 -0.04780408163265306
  0.09859591836734694
 -0.0006389755902360891
  0.03236974789915966
  0.057536454581832736

julia&gt; result.bestIndex
5</code></pre><p><strong>References</strong></p><p>İşletmeciler, Mühendisler ve Yöneticiler için Operasyonel, Yönetsel ve Stratejik Problemlerin Çözümünde Çok Kriterli Karar verme Yöntemleri, Editörler: Bahadır Fatih Yıldırım ve Emrah Önder, Dora, 2. Basım, 2015, ISBN: 978-605-9929-44-8</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/fcfab8266915b131f587bf03a9a1e2b1bec357ac/src/promethee.jl#L67-L142">source</a></section></article><h2 id="CoCoSo"><a class="docs-heading-anchor" href="#CoCoSo">CoCoSo</a><a id="CoCoSo-1"></a><a class="docs-heading-anchor-permalink" href="#CoCoSo" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.cocoso" href="#JMcDM.cocoso"><code>JMcDM.cocoso</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    cocoso(decisionMat, weights, fns, lambda)</code></pre><p>Apply CoCoSo (Combined Compromise Solution) method for a given matrix and weights.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fns::Array{Function, 1}</code>: m-vector of functions to be applied on the columns.</li><li><code>lambda::Float64</code>: joint criterion. 0&lt;=lambda&lt;=1, default=0.5.</li></ul><p><strong>Description</strong></p><p>cocoso() applies the CoCoSo method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::CoCoSoResult</code>: CoCoSoResult object that holds multiple outputs including scores, rankings, and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; decmat = [3        12.5        2        120        14        3;
       5        15        3        110        38        4;
       3        13        2        120        19        3;
       4        14        2        100        31        4;
       3        15        1.5        125        40        4]
5×6 Array{Float64,2}:
 3.0  12.5  2.0  120.0  14.0  3.0
 5.0  15.0  3.0  110.0  38.0  4.0
 3.0  13.0  2.0  120.0  19.0  3.0
 4.0  14.0  2.0  100.0  31.0  4.0
 3.0  15.0  1.5  125.0  40.0  4.0

julia&gt; df = makeDecisionMatrix(decmat)
5×6 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4     Crt5     Crt6    
     │ Float64  Float64  Float64  Float64  Float64  Float64 
─────┼──────────────────────────────────────────────────────
   1 │     3.0     12.5      2.0    120.0     14.0      3.0
   2 │     5.0     15.0      3.0    110.0     38.0      4.0
   3 │     3.0     13.0      2.0    120.0     19.0      3.0
   4 │     4.0     14.0      2.0    100.0     31.0      4.0
   5 │     3.0     15.0      1.5    125.0     40.0      4.0

julia&gt; weights = [0.221, 0.159, 0.175, 0.127, 0.117, 0.201];

julia&gt; fns = [maximum, minimum, minimum, maximum, minimum, maximum];

julia&gt; lambda = 0.5;

julia&gt; result = cocoso(df, weights, fns, lambda);

julia&gt; result.scores
7-element Array{Float64,1}:
 2.0413128390265998
 2.787989783418825
 2.8823497955972495
 2.4160457689259287
 1.2986918936013303
 1.4431429073391682
 2.519094173200623

julia&gt; result.bestIndex
3</code></pre><p><strong>References</strong></p><p>Yazdani, M., Zarate, P., Kazimieras Zavadskas, E. and Turskis, Z. (2019), &quot;A combined compromise solution (CoCoSo) method for multi-criteria decision-making problems&quot;, Management Decision, Vol. 57 No. 9, pp. 2501-2519. https://doi.org/10.1108/MD-05-2017-0458</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/fcfab8266915b131f587bf03a9a1e2b1bec357ac/src/cocoso.jl#L1-L69">source</a></section></article><h2 id="Critic"><a class="docs-heading-anchor" href="#Critic">Critic</a><a id="Critic-1"></a><a class="docs-heading-anchor-permalink" href="#Critic" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.critic" href="#JMcDM.critic"><code>JMcDM.critic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    critic(decisionMat, fns)</code></pre><p>Apply CRITIC (Combined Compromise Solution) method for a given matrix and criteria types.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>fns::Array{Function, 1}</code>: m-vector of functions to be applied on the columns.</li></ul><p><strong>Description</strong></p><p>critic() applies the CRITIC method to rank n alterntives subject to m criteria which are supposed to be  either maximized or minimized.</p><p><strong>Output</strong></p><ul><li><code>::CRITICResult</code>: CRITICResult object that holds multiple outputs including weighting and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">
julia&gt; decmat
3×4 Array{Float64,2}:
 12.9918  0.7264  -1.1009  1.59814
  4.1201  5.8824   3.4483  1.02156
  4.1039  0.0     -0.5076  0.984469

julia&gt; df = makeDecisionMatrix(decmat)

3×4 DataFrame
 Row │ Crt1     Crt2     Crt3     Crt4     
     │ Float64  Float64  Float64  Float64  
─────┼─────────────────────────────────────
   1 │ 12.9918   0.7264  -1.1009  1.59814
   2 │  4.1201   5.8824   3.4483  1.02156
   3 │  4.1039   0.0     -0.5076  0.984469

julia&gt; fns = [maximum, maximum, minimum, maximum];

julia&gt; result = critic(df, fns);

julia&gt; result.w
4-element Array{Float64,1}:
 0.16883905506169491
 0.41844653698732126
 0.24912338769165807
 0.16359102025932576

julia&gt; result.bestIndex
2</code></pre><p><strong>References</strong></p><p>Diakoulaki, D., Mavrotas, G., &amp; Papayannakis, L. (1995). Determining objective weights in multiple criteria problems: The critic method. Computers &amp; Operations Research, 22(7), 763–770. doi:10.1016/0305-0548(94)00059-h  Akçakanat, Ö., Aksoy, E., Teker, T. (2018). CRITIC ve MDL Temelli EDAS Yöntemi ile TR-61 Bölgesi Bankalarının Performans Değerlendirmesi. Süleyman Demirel Üniversitesi Sosyal Bilimler Enstitüsü Dergisi, 1 (32), 1-24.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/fcfab8266915b131f587bf03a9a1e2b1bec357ac/src/critic.jl#L1-L55">source</a></section></article><h2 id="CODAS"><a class="docs-heading-anchor" href="#CODAS">CODAS</a><a id="CODAS-1"></a><a class="docs-heading-anchor-permalink" href="#CODAS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JMcDM.codas" href="#JMcDM.codas"><code>JMcDM.codas</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">codas(decisionMat, weights, fs)</code></pre><p>Apply CODAS (COmbinative Distance-based ASsessment) method for a given matrix, weights and, type of criteria.</p><p><strong>Arguments:</strong></p><ul><li><code>decisionMat::DataFrame</code>: n × m matrix of objective values for n alternatives and m criteria </li><li><code>weights::Array{Float64, 1}</code>: m-vector of weights that sum up to 1.0. If the sum of weights is not 1.0, it is automatically normalized.</li><li><code>fs::Array{Function,1}</code>: m-vector of type of criteria. The benefit criteria shown with &quot;maximum&quot;, and the cost criteria shown with &quot;minimum&quot;.</li><li><code>tau::Float64</code>: tau parameter for the algorithm. The default is 0.02.</li></ul><p><strong>Description</strong></p><p>codas() applies the CODAS method to rank n alternatives subject to m criteria and criteria type vector.</p><p><strong>Output</strong></p><ul><li><code>::CODASResult</code>: CODASResult object that holds multiple outputs including scores and best index.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; decmat
7×5 Array{Float64,2}:
 60.0   0.4   2540.0   500.0   990.0
  6.35  0.15  1016.0  3000.0  1041.0
  6.8   0.1   1727.2  1500.0  1676.0
 10.0   0.2   1000.0  2000.0   965.0
  2.5   0.1    560.0   500.0   915.0
  4.5   0.08  1016.0   350.0   508.0
  3.0   0.1   1778.0  1000.0   920.0

julia&gt; df = DataFrame(decmat)
7×5 DataFrame
 Row │ x1       x2       x3       x4       x5      
     │ Float64  Float64  Float64  Float64  Float64 
─────┼─────────────────────────────────────────────
   1 │   60.0      0.4    2540.0    500.0    990.0
   2 │    6.35     0.15   1016.0   3000.0   1041.0
   3 │    6.8      0.1    1727.2   1500.0   1676.0
   4 │   10.0      0.2    1000.0   2000.0    965.0
   5 │    2.5      0.1     560.0    500.0    915.0
   6 │    4.5      0.08   1016.0    350.0    508.0
   7 │    3.0      0.1    1778.0   1000.0    920.0
julia&gt; result = codas(df, w, fs);
julia&gt; result.bestIndex
2
julia&gt; result.scores
7-element Array{Float64,1}:
  0.5121764914884954
  1.463300034504913
  1.0715325899642418
 -0.21246799780012637
 -1.8515205523193041
 -1.1716767695713806
  0.18865620373316055
</code></pre><p><strong>References</strong></p><p>Keshavarz Ghorabaee, M., Zavadskas, E. K., Turskis, Z., &amp; Antucheviciene, J. (2016). A new combinative distance-based assessment (CODAS) method for multi-criteria decision-making. Economic Computation &amp; Economic Cybernetics Studies &amp; Research, 50(3), 25-44.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jbytecode/JMcDM/blob/fcfab8266915b131f587bf03a9a1e2b1bec357ac/src/codas.jl#L1-L53">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="../game/">Zero-sum Game Solver »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 14 March 2021 14:37">Sunday 14 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
